= 4.8-引用传递的骗局
WEN Pingbo <wengpingbo AT gmail.com>
Jul 31 2013

在以前的C教科书上，一直教导我们，C语言函数有两种传递参数的方式：值传递和引用传递。但是，今天在看c-faq的4.11的时候，才了解到真相。其实严格意义上来讲，C语言只有值传递，但是编译器可以模拟引用传递，但本质上，还是值传递。
举个例子：

[source, c]
----
void f(int *p);

int i;
f(&i);
----

这是一个很正常的指针传递，我们一般把这个称为引用传递。对于整数i来说，确实是这样的，但是对于int指针来说，f函数调用，只是把i的地址复制一份给p，这个行为其实就是传值。

可能这个例子不是很明显，那么引用一下c-faq上的一个例子：

[source, c]
----
void f(int *p)
{
	static int dummy=5;
	p=&dummy;
}

int *i;
f(i);
----

指针i在f函数调用后，是否改变了？答案是否，因为f(i)是一个传值，只是复制了一份i的值而已，尽管在f函数内部改变了，但是只是改变了i的复制版。这其实是C语言初学者，经常犯的错误，把传值理解为传地址。但是为什么还是有很多人在这个代码上，犯糊涂了呢？因为我们默认把传指针直接当作引用传递的替身了。其实，我们为了传递一个指针的引用，应该用指针的指针：

[source, c]
----
void f(int **p)
{
	static int dummy=5;
	*p=&dummy;
}

int *i;
f(&i);
----

这样，对于指针**p来说，f函数是传值，但是对于指针*p来说，其实是传地址，跟上面是一个道理。

并且这也可以用来解释：为什么free掉一个指针所指向的内存后，指针的值没有发生改变？如果每次free内存后，把相应的指针重置为0，这样不是更安全么？
为什么C中标准函数free没有这样来设计？由于C语言的天生的传值特性，如果你需要修改这个指针本身的值，那么意味着free的形参必须为指针的指针才行。