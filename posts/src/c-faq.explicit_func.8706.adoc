= 1.25-隐式函数声明
WEN Pingbo <wengpingbo@gmail.com>
Aug 11 2013

在C语言中，隐式函数声明是指函数在调用之前没有明确的声明或定义。
不同的编译器对待隐式函数声明的方式不同。在GCC中，编译器只会给出一个警告，但是只要不和默认函数原型冲突，编译器是不会报错的。
下面来看一个实验：

[source, c]
.test.c
----
#include <stdio.h>

int f1()
{
	return f2();
}

int f2(int i)
{
	return 1;
}

int main(int argc, char * argv[])
{
	printf("%d\n",f1());
	return 0;
}
----

当你直接用gcc test.c的方式编译这个程序的时候，编译器是不会报错的，并且能够正常通过编译。

但是当你把上面的f2函数的返回类型改为char后，还是按照原先的方式编译（gcc test.c），你会发现，编译器会报错，提示在f2定义的那个地方和函数f2类型冲突。

怎么会出现类型冲突的错误？我之前有定义f2么？

其实这中间就是隐式函数声明在捣鬼。在gcc中，如果编译器碰到一个未声明的函数调用，编译器默认会把这个函数的原型当作"int f()"。也就是说这个函数可以接受任意的参数，并且返回一个整型数。这也是为什么第一次编译的时候，编译器是可以通过编译的，并且程序运行正常。因为下面的f2定义刚好和默认的函数原型兼容。

但是，如果我们把返回类型换成char之后，这就和前面的函数原型不兼容了。就相当于同一个文件中出现两个对同一个名字的不同的函数声明，这在C语言中，当然是不允许的，所以编译器会报错：类型冲突。

在C89的规范中，是允许这种隐式函数声明，且gcc默认是按照c89的标准来编译程序的，这也是为什么gcc在第一次编译的时候，连一个警告都不出，其实你可以加一个-Wall的参数，gcc就会出先警告：隐式函数声明。

在C99的规范，已经不允许隐式函数声明了。所以如果你在用gcc编译的时候，加上-std=c99的时候，编译器马上会出现一个警告：隐式函数声明。如果你再加上一个-Werror的选项的话，那就直接出现错误了。

从这也可以看出，不同的标准之间的差异。以后编译程序的时候，还是尽量加上-Wall -std=c99，可以发现很多隐藏的错误。